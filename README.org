#+title: Leetcode
#+startup: content

* leetcode [13/144]
** DONE 2. [[https://leetcode.com/problems/add-two-numbers/description/][Add Two Numbers]] :Medium:LinkedList:Math:Recursion:
Point:
- how to create a LinkedList
- how to iterable a linkedlist
- if the sum value over then 10 should carry it

#+begin_src java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode ret = new ListNode(0);
        ListNode current = ret;
        // to save the current value
        int carry = 0;
        // loop the linked list
        while (l1 != null || l2 != null || carry > 0) {
            int sum = 0;
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }
            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }
            sum += carry;
            carry = sum / 10;
            current.next = new ListNode(sum % 10);
            current = current.next;
        }

        return ret.next;
    }
}
#+end_src

** DONE 3. [[https://leetcode.com/problems/longest-substring-without-repeating-characters/][Longest Substring Without Repeating Characters]] :Medium:HashTable:String:SlidingWindow:
Point:
- The best solution is sliding window
- what is the sliding window
  sliding window is a algorithm to solve a sub sequence problem
- which problem is sliding window problem
  #+begin_quote
  1. First thing is, we have given something like an "Array" | OR | "String"
  2. Second thing is, they are talking about either "subsequence" | OR | "substring"
  3. And third most thing is, either we have given a "window size i.e. k" | OR | we have to "manually find out window size"
  #+end_quote
  If your score lies from 2/3 to 3/3 that's a gauranteed sliding window problem
- the template code for sliding window
  #+begin_quote
    while(j < size()){
    // Calculation's happen's here
-----------------------------------------------
    if(condition < k){
        j++;
    }
-----------------------------------------------
-----------------------------------------------
    else if(condition == k){
        // ans <-- calculation
        j++;
    }
----------------------------------------------
----------------------------------------------
    else if(condition > k){
        while(condition > k){
            // remove calculation for i
            i++;
        }
        j++;
    }
----------------------------------------------
    }
    return ans;
  #+end_quote
- the approach
  1. Use sliding window with hashset, use left and right pointers to move the window .
  2. If the set doesn't contains character then first add into the set and calculate the maxLength hand-in-hand...
  3. if character already present in the set that means you have to move your sliding window by 1 , before that you have to remove all the characters that are infront of the character that is present already in window before.
  4. Now you have to remove that character also and move the left pointer and also add the new character into the set.
- chinese approach
  1. 首先呢，就是获取原字符串的长度。
  2. 接着维护一个窗口(数组、哈希、队列)
  3. 窗口一步一步向右扩展
  4. 窗口在向右扩展滑动过程，需要判断左边是否需要缩减
  5. 最后比较更新答案
     #+begin_quote
  int left =0，right = 0;
  while (right < s.size()){
    //增大窗口
    window.add(s[right]);
    right++;

    while (window needs shrink){
      //缩小窗口
      window.remove (s[left]);
      left ++;
    }
  }
     #+end_quote

#+begin_src java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashSet set = new HashSet<>();
        int windowSize = 0;
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            if (!set.contains(s.charAt(i))) {
                set.add(s.charAt(i));
                result = Math.max(result, i - windowSize + 1);
            } else {
                while(s.charAt(windowSize)!=s.charAt(i)){
                    set.remove(s.charAt(windowSize));
                    windowSize++;
                }
                set.remove(s.charAt(windowSize));
                windowSize++;
                set.add(s.charAt(i));
            }
        }
        return result;
    }
}
#+end_src
** DONE 4.[[https://leetcode.com/problems/median-of-two-sorted-arrays][Median of Two Sorted Arrays]] :Hard:Array:BinarySearch:DivideandConquer:
SCHEDULED: <2023-04-12 Wed>
Point:
- the one of solution for this problem is merge the two arrays to a new sorted array. but the time complex is O(m + n) space complex is O(m + n)
- the another [[https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/3382662/best-concise-o-log-min-n1-n2-solution-iterative-c-binary-search/][solution]] is save the space and time complex is O(log(n + m))

#+begin_src java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int l1 = nums1.length;
        int l2 = nums2.length;
        int n = l1 + l2;
        int[] newArray = new int[n];
        int i = 0, j = 0, k = 0;
        while (i <= l1 && j <= l2) {
            if (i == l1) {
                while(j < l2) newArray[k++] = nums2[j++];
                break;
            } else if (j == l2) {
                while(i < l1) newArray[k++] = nums1[i++];
                break;
            }

            if (nums1[i] < nums2[j]) {
                newArray[k++] = nums1[i++];
            } else {
                newArray[k++] = nums2[j++];
            }
        }

        return n%2 == 0 ? (newArray[n/2 - 1] + newArray[n / 2]) / 2.0 : newArray[n/2];

    }
}
#+end_src
** DONE 5.[[https://leetcode.com/problems/longest-palindromic-substring][Longest Palindromic Substring]] :Medium:String:DynamicProgramming:
SCHEDULED: <2023-04-12 Wed>
Point:
- we have two cases, if the middle index is i:
  1. the char in i - 1 is equals to i + 1. the middle char is one
     #+begin_quote
        adbabdc
     #+end_quote
  2. the char in i is equals to i + 1. the middle char is two
     #+begin_quote
        baac

        abba
     #+end_quote
- this solution time complex is O(n^2) and space complex is O(n)

#+begin_src java
class Solution {

    String result = "";
    public String longestPalindrome(String s) {
        if (s.length() < 2) {
            return s;
        }
        for (int i = 0; i < s.length(); i++) {
            expand(s, i, i);
            expand(s, i, i + 1);
        }
        return result;
    }

    public void expand(String s, int left, int right) {
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) != s.charAt(right)) {
                break;
            }
            left--;
            right++;
        }
        if (result.length() < (right - left - 1)) {
            result = s.substring(left + 1, right);
        }
    }
}
#+end_src
** DONE 7.[[https://leetcode.com/problems/reverse-integer][Reverse Integer]] :Medium:Math:
SCHEDULED: <2023-04-13 Thu>
Point:
- this problem is easy to to it loop the x and use x % 10 to get the last value and use x / 10 to reduse the value
- the point of this problem is how to deal with the overflow problem 1000000009 --> 9000000001
#+begin_src java
class Solution {
    public int reverse(int x) {
        int result = 0;
        while (x != 0) {
            // if result > Integer.MAX_VALUE then result / 10 > Integer.MAX_VALUE. result * 10 is overflow
            if (Math.abs(result) > Integer.MAX_VALUE / 10) return 0;
            result = result * 10 + x % 10;
            x = x / 10;
        }

        return result;
    }
}
#+end_src

** DONE 8.[[https://leetcode.com/problems/string-to-integer-atoi][String to Integer (atoi)]] :Medium:String:
SCHEDULED: <2023-04-13 Thu>
Point:
- Start traversing the provided string(str)
- Skip all the leading white spaces. eg: " -123456" --> "-123456"
- Check for sign cases(+-). eg: "-123456". If +, then set the variable(boolean) isNegative to true and if it's -, set isNegative to false
- Iterate over the next remaining characters and keep adding them in result by converting the digits(in character form) to integer form. eg: "-123456" --> -123456, until the non-digit character is found.
#+begin_src java
class Solution {
    public int myAtoi(String s) {
        int result = 0;
        int sign = 1;
        int index = 0;

        if (s == null || s.length() == 0) {
            return 0;
        }

        while (index < s.length() && s.charAt(index) == ' ') {
            index++;
        }
        if (index < s.length()) {
            if (s.charAt(index) == '+') {
                sign = 1;
                index++;
            } else if (s.charAt(index) == '-') {
                sign = -1;
                index++;
            }
        }


        while (index < s.length() && (s.charAt(index) <= '9' && s.charAt(index) >= '0')){
            int num = (s.charAt(index) - '0');
            if (Math.abs(result) > Integer.MAX_VALUE / 10 || (Math.abs(result) >= Integer.MAX_VALUE / 10 && num > 7)) {
                if (sign == -1) {
                    return Integer.MIN_VALUE;
                } else {
                    return Integer.MAX_VALUE;
                }
            };
            result = result * 10 + num;
            index++;
        }
        return result * sign;
    }
}
#+end_src

** DONE 10.[[https://leetcode.com/problems/regular-expression-matching][Regular Expression Matching]] :Hard:String:DynamicProgramming:Recursion:
SCHEDULED: <2023-04-14 Fri>
Point:
- this is a DP problem (Dynamic Programming).
- which problem is dp problem
  1.
- how to solve a DP problem:
  1.
- how to solve this problem [[https://leetcode.com/problems/regular-expression-matching/solutions/191830/java-dp-solution-beats-100-with-explanation/?orderBy=most_votes][sove this problem with dp]]
  Here the approach is very simple we basically must create a DP to store the states. For any DP problem all follow the same rule that we should memoize the truth value of (n,m)(n,m)(n,m) then we need the values of (n−1,m)(n-1 , m)(n−1,m) or (n,m−1)(n ,m-1)(n,m−1) or (n−1,m−1)(n-1 , m-1)(n−1,m−1) this would be the whole point of DP.

#+begin_src java
class Solution {
    public boolean isMatch(String s, String p) {

        if (p == null || p.length() == 0) return (s == null || s.length() == 0);

        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        dp[0][0] = true;
        for (int i=2; i<=p.length(); i++) {
            dp[0][i] = p.charAt(i-1) == '*' && dp[0][i-2];
        }

        for (int i = 1; i <= p.length(); i++) {
            for (int j = 1; j <= s.length(); j++) {
                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == '.') {
                    dp[j][i] = dp[j-1][i-1];
                } else if (p.charAt(i - 1) == '*') {
                    dp[j][i] = dp[j][i-2] || ((s.charAt(j-1) == p.charAt(i-2) || p.charAt(i-2) == '.') && dp[j-1][i]);
                }
            }
        }
        return dp[s.length()][p.length()];
    }
}
#+end_src

** DONE 11.[[https://leetcode.com/problems/container-with-most-water][Container With Most Water]] :Medium:Array:TwoPointers:Greedy:
SCHEDULED: <2023-04-14 Fri>
Point:
- the height is the num in the array and the width is the index between two nums
  area = min(left, right) * (right - left)
  so if we want to get a biggest area, we should to get a highest height and largest width
#+begin_src java
class Solution {
    public int maxArea(int[] height) {
        int i = 0, j = height.length - 1;
        int max = 0;
        while (i <= j - 1) {
            int area = (j - i) * Math.min(height[i], height[j]);
            max = Math.max(area, max);
            if (height[i] < height[j]) {
                i++;
            } else {
                j--;
            }
        }
        return max;
    }
}
#+end_src
** DONE 13.[[https://leetcode.com/problems/roman-to-integer][Roman to Integer]] :Easy:HashTable:Math:String:
SCHEDULED: <2023-04-15 Sat>
#+begin_src java
//optimised -> should have thought from right to left.
class Solution {
    public int romanToInt(String s) {
        int res = 0, num = 0;
        for (int i = s.length()-1; i>=0; i--) {
            switch(s.charAt(i)) {
                case 'I': num = 1; break;
                case 'V': num = 5; break;
                case 'X': num = 10; break;
                case 'L': num = 50; break;
                case 'C': num = 100; break;
                case 'D': num = 500; break;
                case 'M': num = 1000; break;
            }
            if (4 * num > res) res += num;
            else res -= num;
    }
        return res;

    }
}
#+end_src
** DONE 14.[[https://leetcode.com/problems/longest-common-prefix][Longest Common Prefix]] :Easy:String:Trie:
SCHEDULED: <2023-04-15 Sat>
Point:

This code is used to find the longest common prefix of an array of strings, which is defined as the longest string that is a prefix of all the strings in the array. By sorting the array and then comparing the first and last elements, the code is able to find the common prefix that would be shared by all strings in the array.

#+begin_src java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String min = strs[0];
        String max = strs[strs.length - 1];
        int index = 0;

        while (index < min.length() && index < max.length()) {
            if (min.charAt(index) == max.charAt(index)) {
                index++;
            } else {
                break;
            }
        }
        return min.substring(0, index);
    }
}
#+end_src

** DONE 15.[[https://leetcode.com/problems/3sum][3Sum]] :Medium:Array:TwoPointers:Sorting:
SCHEDULED: <2023-04-16 Sun>
- X(time complex is too long) Solved using Array(Three Nested Loop) + Sorting + Hash Table(set). Brute Force Approach

  #+begin_src java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        if (nums == null || nums.length < 3) return new ArrayList<>();

        Arrays.sort(nums);
        Set<List<Integer>> result = new HashSet<>();

        for(int i =0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                for (int z= j + 1; z < nums.length; z++) {
                    if (nums[i] + nums[j] + nums[z] == 0 ) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[z]));
                    }
                }
            }
        }
        return new ArrayList<>(result);
    }
}
  #+end_src
- Solved using Array(Two Nested Loop) + Sorting. Optimized Approach.
  #+begin_src java
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();

        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {

            // avoid duplicate A
            if (i >= 1 && nums[i] == nums[i - 1])
                continue;

            int left = i + 1;
            int right = nums.length - 1;
            while (left < right) {
                int sum = nums[left] + nums[right] + nums[i];
                if (sum == 0) {
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[left]);
                    temp.add(nums[i]);
                    temp.add(nums[right]);
                    result.add(temp);
                    while (left < right && nums[left] == nums[left + 1])
                        left++;
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    left++;
                    right--;

                } else if (sum > 0) {
                    right--;
                    continue;
                } else if (sum < 0) {
                    left++;
                    continue;
                }
            }
        }

        return result;
    }
}
  #+end_src
** DONE 17.[[https://leetcode.com/problems/letter-combinations-of-a-phone-number][Letter Combinations of a Phone Number]] :Medium:HashTable:String:Backtracking:
SCHEDULED: <2023-04-16 Sun>
- this is a backtracking problem. you can read this page [[https://www.geeksforgeeks.org/introduction-to-backtracking-data-structure-and-algorithm-tutorials/][backtracking]]
- To solve this problem, we can use a recursive approach. We define a recursive function that takes the input string, an output string to keep track of the current combination of letters, an index to keep track of the current digit in the input string, a vector to store all possible combinations, and a mapping array that maps each digit to the corresponding set of letters.

  #+begin_src java
class Solution {
    private static final String[] KEYS = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};

    public List<String> letterCombinations(String digits) {
        List<String> result = new ArrayList<>();
        if (digits == null || digits.length() == 0) {
            return result;
        }
        helper(result, digits, new StringBuilder(), 0);
        return result;
    }

    private void helper(List<String> result, String digits, StringBuilder sb, int index) {
        if (index == digits.length()) {
            result.add(sb.toString());
            return;
        }
        String letters = KEYS[digits.charAt(index) - '0'];
        for (char c : letters.toCharArray()) {
            sb.append(c);
            helper(result, digits, sb, index + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
  #+end_src

** DONE 19.[[https://leetcode.com/problems/remove-nth-node-from-end-of-list][Remove Nth Node From End of List]] :Medium:LinkedList:TwoPointers:
SCHEDULED: <2023-04-18 Tue>
Points:
- with a single linked list, the only way to find the end of the list, and thus the n'th node from the end, is to actually iterate all the way to the end.
- we can simply stagger our two pointers by n nodes by giving the first pointer (fast) a head start before starting the second pointer (slow). Doing this will cause slow to reach the n'th node from the end at the same time that fast reaches the end.

  #+begin_src java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast = head, slow = head;

        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        // n == ListNode.length
        if (fast == null) return head.next;

        // we neet to find the (n + 1)th node to delete the nth node, so we should test the fast.next == null not fast == null
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        slow.next = slow.next.next;

        return head;
    }


}
  #+end_src
** TODO 20.[[https://leetcode.com/problems/valid-parentheses][Valid Parentheses]] :Easy:String:Stack:
SCHEDULED: <2023-04-18 Tue>
Point:
-  this problem we can use stack to solve it
#+begin_src java
public class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.empty()) {
                    return false;
                }
                if (c == ')' && stack.peek() == '(') {
                    stack.pop();
                } else if (c == '}' && stack.peek() == '{') {
                    stack.pop();
                } else if (c == ']' && stack.peek() == '[') {
                    stack.pop();
                } else {
                    return false;
                }
            }
        }
        return stack.empty();
    }
}
#+end_src
** TODO 21.[[https://leetcode.com/problems/merge-two-sorted-lists][Merge Two Sorted Lists]] :Easy:LinkedList:Recursion:
SCHEDULED: <2023-04-19 Wed>
** TODO 22.[[https://leetcode.com/problems/generate-parentheses][Generate Parentheses]] :Medium:String:DynamicProgramming:Backtracking:
SCHEDULED: <2023-04-19 Wed>
** TODO 23.[[https://leetcode.com/problems/merge-k-sorted-lists][Merge k Sorted Lists]] :Hard:LinkedList:DivideandConquer:HeapPriorityQueue:MergeSort:
SCHEDULED: <2023-04-20 Thu>
** TODO 26.[[https://leetcode.com/problems/remove-duplicates-from-sorted-array][Remove Duplicates from Sorted Array]] :Easy:Array:TwoPointers:
SCHEDULED: <2023-04-20 Thu>
** TODO 28.[[https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string][Find the Index of the First Occurrence in a String]] :Easy:TwoPointers:String:StringMatching:
SCHEDULED: <2023-04-21 Fri>
** TODO 29.[[https://leetcode.com/problems/divide-two-integers][Divide Two Integers]] :Medium:Math:BitManipulation:
SCHEDULED: <2023-04-21 Fri>
** TODO 33.[[https://leetcode.com/problems/search-in-rotated-sorted-array][Search in Rotated Sorted Array]] :Medium:Array:BinarySearch:
** TODO 34.[[https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array][Find First and Last Position of Element in Sorted Array]] :Medium:Array:BinarySearch:
** TODO 36.[[https://leetcode.com/problems/valid-sudoku][Valid Sudoku]] :Medium:Array:HashTable:Matrix:
** TODO 38.[[https://leetcode.com/problems/count-and-say][Count and Say]] :Medium:String:
** TODO 41.[[https://leetcode.com/problems/first-missing-positive][First Missing Positive]] :Hard:Array:HashTable:
** TODO 42.[[https://leetcode.com/problems/trapping-rain-water][Trapping Rain Water]] :Hard:Array:TwoPointers:DynamicProgramming:Stack:MonotonicStack:
** TODO 44.[[https://leetcode.com/problems/wildcard-matching][Wildcard Matching]] :Hard:String:DynamicProgramming:Greedy:Recursion:
** TODO 46.[[https://leetcode.com/problems/permutations][Permutations]] :Medium:Array:Backtracking:
** TODO 48.[[https://leetcode.com/problems/rotate-image][Rotate Image]] :Medium:Array:Math:Matrix:
** TODO 49.[[https://leetcode.com/problems/group-anagrams][Group Anagrams]] :Medium:Array:HashTable:String:Sorting:
** TODO 50.[[https://leetcode.com/problems/powx-n][Pow(x, n)]] :Medium:Math:Recursion:
** TODO 53.[[https://leetcode.com/problems/maximum-subarray][Maximum Subarray]] :Medium:Array:DivideandConquer:DynamicProgramming:
** TODO 54.[[https://leetcode.com/problems/spiral-matrix][Spiral Matrix]] :Medium:Array:Matrix:Simulation:
** TODO 55.[[https://leetcode.com/problems/jump-game][Jump Game]] :Medium:Array:DynamicProgramming:Greedy:
** TODO 56.[[https://leetcode.com/problems/merge-intervals][Merge Intervals]] :Medium:Array:Sorting:
** TODO 62.[[https://leetcode.com/problems/unique-paths][Unique Paths]] :Medium:Math:DynamicProgramming:Combinatorics:
** TODO 66.[[https://leetcode.com/problems/plus-one][Plus One]] :Easy:Array:Math:
** TODO 69.[[https://leetcode.com/problems/sqrtx][Sqrt(x)]] :Easy:Math:BinarySearch:
** TODO 70.[[https://leetcode.com/problems/climbing-stairs][Climbing Stairs]] :Easy:Math:DynamicProgramming:Memoization:
** TODO 73.[[https://leetcode.com/problems/set-matrix-zeroes][Set Matrix Zeroes]] :Medium:Array:HashTable:Matrix:
** TODO 75.[[https://leetcode.com/problems/sort-colors][Sort Colors]] :Medium:Array:TwoPointers:Sorting:
** TODO 76.[[https://leetcode.com/problems/minimum-window-substring][Minimum Window Substring]] :Hard:HashTable:String:SlidingWindow:
** TODO 78.[[https://leetcode.com/problems/subsets][Subsets]] :Medium:Array:Backtracking:BitManipulation:
** TODO 79.[[https://leetcode.com/problems/word-search][Word Search]] :Medium:Array:Backtracking:Matrix:
** TODO 84.[[https://leetcode.com/problems/largest-rectangle-in-histogram][Largest Rectangle in Histogram]] :Hard:Array:Stack:MonotonicStack:
** TODO 88.[[https://leetcode.com/problems/merge-sorted-array][Merge Sorted Array]] :Easy:Array:TwoPointers:Sorting:
** TODO 91.[[https://leetcode.com/problems/decode-ways][Decode Ways]] :Medium:String:DynamicProgramming:
** TODO 94.[[https://leetcode.com/problems/binary-tree-inorder-traversal][Binary Tree Inorder Traversal]] :Easy:Stack:Tree:DepthFirstSearch:BinaryTree:
** TODO 98.[[https://leetcode.com/problems/validate-binary-search-tree][Validate Binary Search Tree]] :Medium:Tree:DepthFirstSearch:BinarySearchTree:BinaryTree:
** TODO 101.[[https://leetcode.com/problems/symmetric-tree][Symmetric Tree]] :Easy:Tree:DepthFirstSearch:BreadthFirstSearch:BinaryTree:
** TODO 102.[[https://leetcode.com/problems/binary-tree-level-order-traversal][Binary Tree Level Order Traversal]] :Medium:Tree:BreadthFirstSearch:BinaryTree:
** TODO 103.[[https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal][Binary Tree Zigzag Level Order Traversal]] :Medium:Tree:BreadthFirstSearch:BinaryTree:
** TODO 104.[[https://leetcode.com/problems/maximum-depth-of-binary-tree][Maximum Depth of Binary Tree]] :Easy:Tree:DepthFirstSearch:BreadthFirstSearch:BinaryTree:
** TODO 105.[[https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal][Construct Binary Tree from Preorder and Inorder Traversal]] :Medium:Array:HashTable:DivideandConquer:Tree:BinaryTree:
** TODO 108.[[https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree][Convert Sorted Array to Binary Search Tree]] :Easy:Array:DivideandConquer:Tree:BinarySearchTree:BinaryTree:
** TODO 116.[[https://leetcode.com/problems/populating-next-right-pointers-in-each-node][Populating Next Right Pointers in Each Node]] :Medium:LinkedList:Tree:DepthFirstSearch:BreadthFirstSearch:BinaryTree:
** TODO 118.[[https://leetcode.com/problems/pascals-triangle][Pascal's Triangle]] :Easy:Array:DynamicProgramming:
** TODO 121.[[https://leetcode.com/problems/best-time-to-buy-and-sell-stock][Best Time to Buy and Sell Stock]] :Easy:Array:DynamicProgramming:
** TODO 122.[[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii][Best Time to Buy and Sell Stock II]] :Medium:Array:DynamicProgramming:Greedy:
** TODO 124.[[https://leetcode.com/problems/binary-tree-maximum-path-sum][Binary Tree Maximum Path Sum]] :Hard:DynamicProgramming:Tree:DepthFirstSearch:BinaryTree:
** TODO 125.[[https://leetcode.com/problems/valid-palindrome][Valid Palindrome]] :Easy:TwoPointers:String:
** TODO 127.[[https://leetcode.com/problems/word-ladder][Word Ladder]] :Hard:HashTable:String:BreadthFirstSearch:
** TODO 128.[[https://leetcode.com/problems/longest-consecutive-sequence][Longest Consecutive Sequence]] :Medium:Array:HashTable:UnionFind:
** TODO 130.[[https://leetcode.com/problems/surrounded-regions][Surrounded Regions]] :Medium:Array:DepthFirstSearch:BreadthFirstSearch:UnionFind:Matrix:
** TODO 131.[[https://leetcode.com/problems/palindrome-partitioning][Palindrome Partitioning]] :Medium:String:DynamicProgramming:Backtracking:
** TODO 134.[[https://leetcode.com/problems/gas-station][Gas Station]] :Medium:Array:Greedy:
** TODO 136.[[https://leetcode.com/problems/single-number][Single Number]] :Easy:Array:BitManipulation:
** TODO 138.[[https://leetcode.com/problems/copy-list-with-random-pointer][Copy List with Random Pointer]] :Medium:HashTable:LinkedList:
** TODO 139.[[https://leetcode.com/problems/word-break][Word Break]] :Medium:Array:HashTable:String:DynamicProgramming:Trie:Memoization:
** TODO 140.[[https://leetcode.com/problems/word-break-ii][Word Break II]] :Hard:Array:HashTable:String:DynamicProgramming:Backtracking:Trie:Memoization:
** TODO 141.[[https://leetcode.com/problems/linked-list-cycle][Linked List Cycle]] :Easy:HashTable:LinkedList:TwoPointers:
** TODO 146.[[https://leetcode.com/problems/lru-cache][LRU Cache]] :Medium:HashTable:LinkedList:Design:DoublyLinkedList:
** TODO 148.[[https://leetcode.com/problems/sort-list][Sort List]] :Medium:LinkedList:TwoPointers:DivideandConquer:Sorting:MergeSort:
** TODO 149.[[https://leetcode.com/problems/max-points-on-a-line][Max Points on a Line]] :Hard:Array:HashTable:Math:Geometry:
** TODO 150.[[https://leetcode.com/problems/evaluate-reverse-polish-notation][Evaluate Reverse Polish Notation]] :Medium:Array:Math:Stack:
** TODO 152.[[https://leetcode.com/problems/maximum-product-subarray][Maximum Product Subarray]] :Medium:Array:DynamicProgramming:
** TODO 155.[[https://leetcode.com/problems/min-stack][Min Stack]] :Medium:Stack:Design:
** TODO 160.[[https://leetcode.com/problems/intersection-of-two-linked-lists][Intersection of Two Linked Lists]] :Easy:HashTable:LinkedList:TwoPointers:
** TODO 162.[[https://leetcode.com/problems/find-peak-element][Find Peak Element]] :Medium:Array:BinarySearch:
** TODO 163.[[https://leetcode.com/problems/missing-ranges][Missing Ranges]] :Easy:Array:
** TODO 166.[[https://leetcode.com/problems/fraction-to-recurring-decimal][Fraction to Recurring Decimal]] :Medium:HashTable:Math:String:
** TODO 169.[[https://leetcode.com/problems/majority-element][Majority Element]] :Easy:Array:HashTable:DivideandConquer:Sorting:Counting:
** TODO 171.[[https://leetcode.com/problems/excel-sheet-column-number][Excel Sheet Column Number]] :Easy:Math:String:
** TODO 172.[[https://leetcode.com/problems/factorial-trailing-zeroes][Factorial Trailing Zeroes]] :Medium:Math:
** TODO 179.[[https://leetcode.com/problems/largest-number][Largest Number]] :Medium:Array:String:Greedy:Sorting:
** TODO 189.[[https://leetcode.com/problems/rotate-array][Rotate Array]] :Medium:Array:Math:TwoPointers:
** TODO 190.[[https://leetcode.com/problems/reverse-bits][Reverse Bits]] :Easy:DivideandConquer:BitManipulation:
** TODO 191.[[https://leetcode.com/problems/number-of-1-bits][Number of 1 Bits]] :Easy:DivideandConquer:BitManipulation:
** TODO 198.[[https://leetcode.com/problems/house-robber][House Robber]] :Medium:Array:DynamicProgramming:
** TODO 200.[[https://leetcode.com/problems/number-of-islands][Number of Islands]] :Medium:Array:DepthFirstSearch:BreadthFirstSearch:UnionFind:Matrix:
** TODO 202.[[https://leetcode.com/problems/happy-number][Happy Number]] :Easy:HashTable:Math:TwoPointers:
** TODO 204.[[https://leetcode.com/problems/count-primes][Count Primes]] :Medium:Array:Math:Enumeration:NumberTheory:
** TODO 206.[[https://leetcode.com/problems/reverse-linked-list][Reverse Linked List]] :Easy:LinkedList:Recursion:
** TODO 207.[[https://leetcode.com/problems/course-schedule][Course Schedule]] :Medium:DepthFirstSearch:BreadthFirstSearch:Graph:TopologicalSort:
** TODO 208.[[https://leetcode.com/problems/implement-trie-prefix-tree][Implement Trie (Prefix Tree)]] :Medium:HashTable:String:Design:Trie:
** TODO 210.[[https://leetcode.com/problems/course-schedule-ii][Course Schedule II]] :Medium:DepthFirstSearch:BreadthFirstSearch:Graph:TopologicalSort:
** TODO 212.[[https://leetcode.com/problems/word-search-ii][Word Search II]] :Hard:Array:String:Backtracking:Trie:Matrix:
** TODO 215.[[https://leetcode.com/problems/kth-largest-element-in-an-array][Kth Largest Element in an Array]] :Medium:Array:DivideandConquer:Sorting:HeapPriorityQueue:Quickselect:
** TODO 217.[[https://leetcode.com/problems/contains-duplicate][Contains Duplicate]] :Easy:Array:HashTable:Sorting:
** TODO 218.[[https://leetcode.com/problems/the-skyline-problem][The Skyline Problem]] :Hard:Array:DivideandConquer:BinaryIndexedTree:SegmentTree:LineSweep:HeapPriorityQueue:OrderedSet:
** TODO 227.[[https://leetcode.com/problems/basic-calculator-ii][Basic Calculator II]] :Medium:Math:String:Stack:
** TODO 230.[[https://leetcode.com/problems/kth-smallest-element-in-a-bst][Kth Smallest Element in a BST]] :Medium:Tree:DepthFirstSearch:BinarySearchTree:BinaryTree:
** TODO 234.[[https://leetcode.com/problems/palindrome-linked-list][Palindrome Linked List]] :Easy:LinkedList:TwoPointers:Stack:Recursion:
** TODO 236.[[https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree][Lowest Common Ancestor of a Binary Tree]] :Medium:Tree:DepthFirstSearch:BinaryTree:
** TODO 237.[[https://leetcode.com/problems/delete-node-in-a-linked-list][Delete Node in a Linked List]] :Medium:LinkedList:
** TODO 238.[[https://leetcode.com/problems/product-of-array-except-self][Product of Array Except Self]] :Medium:Array:PrefixSum:
** TODO 239.[[https://leetcode.com/problems/sliding-window-maximum][Sliding Window Maximum]] :Hard:Array:Queue:SlidingWindow:HeapPriorityQueue:MonotonicQueue:
** TODO 240.[[https://leetcode.com/problems/search-a-2d-matrix-ii][Search a 2D Matrix II]] :Medium:Array:BinarySearch:DivideandConquer:Matrix:
** TODO 242.[[https://leetcode.com/problems/valid-anagram][Valid Anagram]] :Easy:HashTable:String:Sorting:
** TODO 251.[[https://leetcode.com/problems/flatten-2d-vector][Flatten 2D Vector]] :Medium:Array:TwoPointers:Design:Iterator:
** TODO 253.[[https://leetcode.com/problems/meeting-rooms-ii][Meeting Rooms II]] :Medium:Array:TwoPointers:Greedy:Sorting:HeapPriorityQueue:PrefixSum:
** TODO 268.[[https://leetcode.com/problems/missing-number][Missing Number]] :Easy:Array:HashTable:Math:BinarySearch:BitManipulation:Sorting:
** TODO 269.[[https://leetcode.com/problems/alien-dictionary][Alien Dictionary]] :Hard:Array:String:DepthFirstSearch:BreadthFirstSearch:Graph:TopologicalSort:
** TODO 277.[[https://leetcode.com/problems/find-the-celebrity][Find the Celebrity]] :Medium:TwoPointers:Greedy:Graph:Interactive:
** TODO 279.[[https://leetcode.com/problems/perfect-squares][Perfect Squares]] :Medium:Math:DynamicProgramming:BreadthFirstSearch:
** TODO 283.[[https://leetcode.com/problems/move-zeroes][Move Zeroes]] :Easy:Array:TwoPointers:
** TODO 285.[[https://leetcode.com/problems/inorder-successor-in-bst][Inorder Successor in BST]] :Medium:Tree:DepthFirstSearch:BinarySearchTree:BinaryTree:
** TODO 287.[[https://leetcode.com/problems/find-the-duplicate-number][Find the Duplicate Number]] :Medium:Array:TwoPointers:BinarySearch:BitManipulation:
** TODO 289.[[https://leetcode.com/problems/game-of-life][Game of Life]] :Medium:Array:Matrix:Simulation:
** TODO 295.[[https://leetcode.com/problems/find-median-from-data-stream][Find Median from Data Stream]] :Hard:TwoPointers:Design:Sorting:HeapPriorityQueue:DataStream:
** TODO 297.[[https://leetcode.com/problems/serialize-and-deserialize-binary-tree][Serialize and Deserialize Binary Tree]] :Hard:String:Tree:DepthFirstSearch:BreadthFirstSearch:Design:BinaryTree:
** TODO 300.[[https://leetcode.com/problems/longest-increasing-subsequence][Longest Increasing Subsequence]] :Medium:Array:BinarySearch:DynamicProgramming:
** TODO 308.[[https://leetcode.com/problems/range-sum-query-2d-mutable][Range Sum Query 2D - Mutable]] :Hard:Array:Design:BinaryIndexedTree:SegmentTree:Matrix:
** TODO 315.[[https://leetcode.com/problems/count-of-smaller-numbers-after-self][Count of Smaller Numbers After Self]] :Hard:Array:BinarySearch:DivideandConquer:BinaryIndexedTree:SegmentTree:MergeSort:OrderedSet:
** TODO 322.[[https://leetcode.com/problems/coin-change][Coin Change]] :Medium:Array:DynamicProgramming:BreadthFirstSearch:
** TODO 324.[[https://leetcode.com/problems/wiggle-sort-ii][Wiggle Sort II]] :Medium:Array:DivideandConquer:Sorting:Quickselect:
** TODO 326.[[https://leetcode.com/problems/power-of-three][Power of Three]] :Easy:Math:Recursion:
** TODO 328.[[https://leetcode.com/problems/odd-even-linked-list][Odd Even Linked List]] :Medium:LinkedList:
** TODO 329.[[https://leetcode.com/problems/longest-increasing-path-in-a-matrix][Longest Increasing Path in a Matrix]] :Hard:Array:DynamicProgramming:DepthFirstSearch:BreadthFirstSearch:Graph:TopologicalSort:Memoization:Matrix:
** TODO 334.[[https://leetcode.com/problems/increasing-triplet-subsequence][Increasing Triplet Subsequence]] :Medium:Array:Greedy:
** TODO 340.[[https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters][Longest Substring with At Most K Distinct Characters]] :Medium:HashTable:String:SlidingWindow:
** TODO 341.[[https://leetcode.com/problems/flatten-nested-list-iterator][Flatten Nested List Iterator]] :Medium:Stack:Tree:DepthFirstSearch:Design:Queue:Iterator:
** TODO 344.[[https://leetcode.com/problems/reverse-string][Reverse String]] :Easy:TwoPointers:String:
** TODO 347.[[https://leetcode.com/problems/top-k-frequent-elements][Top K Frequent Elements]] :Medium:Array:HashTable:DivideandConquer:Sorting:HeapPriorityQueue:BucketSort:Counting:Quickselect:
** TODO 348.[[https://leetcode.com/problems/design-tic-tac-toe][Design Tic-Tac-Toe]] :Medium:Array:HashTable:Design:Matrix:
** TODO 350.[[https://leetcode.com/problems/intersection-of-two-arrays-ii][Intersection of Two Arrays II]] :Easy:Array:HashTable:TwoPointers:BinarySearch:Sorting:
** TODO 371.[[https://leetcode.com/problems/sum-of-two-integers][Sum of Two Integers]] :Medium:Math:BitManipulation:
** TODO 378.[[https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix][Kth Smallest Element in a Sorted Matrix]] :Medium:Array:BinarySearch:Sorting:HeapPriorityQueue:Matrix:
** TODO 380.[[https://leetcode.com/problems/insert-delete-getrandom-o1][Insert Delete GetRandom O(1)]] :Medium:Array:HashTable:Math:Design:Randomized:
** TODO 384.[[https://leetcode.com/problems/shuffle-an-array][Shuffle an Array]] :Medium:Array:Math:Randomized:
** TODO 387.[[https://leetcode.com/problems/first-unique-character-in-a-string][First Unique Character in a String]] :Easy:HashTable:String:Queue:Counting:
** TODO 395.[[https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters][Longest Substring with At Least K Repeating Characters]] :Medium:HashTable:String:DivideandConquer:SlidingWindow:
** TODO 412.[[https://leetcode.com/problems/fizz-buzz][Fizz Buzz]] :Easy:Math:String:Simulation:
** TODO 454.[[https://leetcode.com/problems/4sum-ii][4Sum II]] :Medium:Array:HashTable:

* hard
** TODO 10.[[https://leetcode.com/problems/regular-expression-matching][Regular Expression Matching]] :Hard:String:DynamicProgramming:Recursion:
